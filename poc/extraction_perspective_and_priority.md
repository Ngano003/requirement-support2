# 構造化抽出の観点リストと優先順位付けガイド

ソフトウェア開発には無数の「観点」が存在しますが、「形式検証（Alloy等）」を用いてヌケモレ矛盾をチェックする場合、**「効果が出やすい観点」と「そうでない観点」**が明確に分かれます。
全てを網羅しようとせず、**「人間が脳内でシミュレーションしきれない複雑な部分」** から優先的に抽出するのが鉄則です。

---

## 1. 抽出観点の全体像（ソフトウェア開発における分類）

形式検証の文脈では、以下の分類が実用的です。前回提示した「4つの次元」をより開発者の視点に近づけたものです。

| ID | 観点カテゴリ | 具体的な内容 | 形式化適合度 (Alloy) |
| :--- | :--- | :--- | :--- |
| **A** | **状態制御 (State Control)** | 画面遷移、ライフサイクル（注文ステータス）、モード遷移 | **◎ (最適)** |
| **B** | **並行・排他 (Concurrency)** | 複数ユーザー同時編集、在庫引き当て、非同期処理の順序 | **◎ (最適)** |
| **C** | **複雑な条件 (Complex Logic)** | 「AかつBまたはCだがDでない時はE」のような各種計算ロジック、権限マトリクス | **○ (有効)** |
| **D** | **データ整合 (Data Integrity)** | DBスキーマの関係性、必須項目、整合性制約（親が消えたら子も消えるか？） | **○ (有効)** |
| **E** | **入出力・I/O (Interface)** | APIパラメータ定義、ファイルフォーマット、画面レイアウト | **△ (不向き)** |
| **F** | **非機能 (Non-Functional)** | パフォーマンス、セキュリティ、ユーザビリティ、ログ出力 | **△ (不向き)** |

※ EやFは、AlloyでやるよりもOpenAPI(Swagger)や負荷テストツールなど別の専用ツールを使う方が効率的です。

---

## 2. 優先順位付けのフレームワーク (Risk x Complexity)

「どこから手をつけるべきか」は、以下のマトリクスで判断します。

| 複雑さ \ 重要度(リスク) | **Low (軽微)** | **High (致命的)** |
| :--- | :--- | :--- |
| **Simple (単純)** | **Lv.4 (後回し/不要)**<br>例: 単純なCRUD、設定画面のUI<br>→ 通常の単体テストで十分。 | **Lv.3 (目視確認)**<br>例: 誤字、単純な権限ミス<br>→ チェックリストやレビューで対応。 |
| **Complex (複雑)** | **Lv.2 (余裕があれば)**<br>例: 複雑な検索フィルタ、稀なUI遷移<br>→ コスパを見て判断。 | **Lv.1 (最優先)**<br>例: **決済フロー、在庫管理、AGV衝突制御**<br>→ **ここを形式検証する！** |

### 優先度 Lv.1 (Must Have): 「動的な競合・矛盾」
人間が脳内で追いきれない領域です。ここにAlloyを投入すると劇的な効果があります。
1.  **ライフサイクル（状態遷移）**: `State`
    *   その注文は「キャンセル済み」なのに「発送」できてしまわないか？
2.  **排他制御（リソース）**: `Resource`
    *   最後の1個の在庫を2人が同時にカートに入れたらどうなるか？

### 優先度 Lv.2 (Should Have): 「静的な複雑条件」
1.  **複合条件（ロジック）**: `Logic`
    *   会員ランク×キャンペーン×クーポン適用時の割引計算ルールに矛盾はないか？

### 優先度 Lv.3 (Nice to Have): 「データの整合性」
1.  **リレーション（データ）**: `Data`
    *   ER図やクラス図で表現できる範囲。ツールでやる価値はあるが、設計図を描けば分かることも多い。

---

## 3. 実践的な導入ステップ

「無限にあって困る」場合は、以下のステップで進めてください。

### Step 1: 「状態遷移図」が描けそうな機能を探す
仕様書の中に「ステータス」「モード」「画面遷移」という言葉が出てきたら、そこがターゲットです。
まずはこれを構造化抽出します。
*   **抽出対象**: 状態一覧、遷移イベント、遷移条件
*   **解決できる課題**: 「どの画面からも戻れない」「特定の条件でスタックする」

### Step 2: 「複数の主体」が登場する機能を探す
「ユーザーAとユーザーB」「AGV1とAGV2」「スマホアプリとWeb管理画面」など、複数のプレイヤーが同じデータを触る箇所です。
*   **抽出対象**: 共有リソース（DB、交差点）、アクション（Read/Write/Lock）
*   **解決できる課題**: 「データの不整合」「早い者勝ち問題」

### Step 3: それ以外は一旦無視する（または別のツールに任せる）
すべての要件をAlloyにする必要はありません。
「APIのレスポンス形式」や「画面のボタンの色」などは、構造化抽出の対象から意図的に外します（スコープ外とします）。

---

## 4. 結論：何から抽出するか？

**「一番バグったら怖くて、かつ一番頭で考えるのが面倒くさいところ」** です。

AGVシステムの例で言えば：
1.  **最優先**: 交差点での衝突回避（複雑 x 致命的） -> **Resource観点**
2.  **次点**: セーフモードやエラーからの復帰手順（複雑 x 重要） -> **State観点**
3.  **後回し**: ログのフォーマット、診断モードの画面表示 -> **I/O観点**

このように「リスク」と「形式化への適合度」でフィルタリングすることで、抽出対象を現実的な範囲（全体の10-20%程度のコアロジック）に絞り込むことができます。
