# 要件定義書のヌケモレ矛盾を網羅的にチェックするための検証観点抽出ガイド

要件定義書から検証観点を「網羅的」に抽出するためのフレームワークです。
自然言語の記述を4つの「次元」に分類し、それぞれに対応するAlloyの検証パターンを当てはめることで、システマチックに自動検証を行うことが可能です。

## 1. 思考フレームワーク：4つの次元

要件記述は必ず以下のいずれか（または複数）の構造を含んでいます。

### (A) 動的次元 (State & Transition)
「いつ、何がどう変化するか」に関する記述。
*   **着眼点**: 状態 (State)、イベント (Event)、遷移 (Transition)
*   **よくある欠陥**:
    *   **Deadlock**: どこへも行けない状態（行き止まり）。
    *   **Unreachable**: どこからも到達できない「孤立した機能/状態」。
    *   **Non-determinism**: 同じ条件なのに複数の遷移先があり、振る舞いが確定しない（仕様の曖昧さ）。

### (B) 論理次元 (Logic & Guard)
「もし〜ならば」という条件分岐や、「〜でなければならない」という制約。
*   **着眼点**: 数値の閾値、条件の組み合わせ、AND/OR/NOT
*   **よくある欠陥**:
    *   **Gap (ヌケ)**: `x > 10` と `x < 5` はあるが、`5 <= x <= 10` の定義がない。
    *   **Overlap (矛盾)**: `x >= 10` でA処理、`x >= 5` でB処理と書かれている時、`x=15`で矛盾する。

### (C) リソース次元 (Concurrency & Resource)
「誰が、何を使うか」に関する記述。特に複数の主体（ユーザー、デバイス）が登場する場合。
*   **着眼点**: 所有権、アクセス権、排他制御、共有リソース
*   **よくある欠陥**:
    *   **Race Condition**: 同時にアクセスした際の順序依存。
    *   **Starvation**: 特定のユーザーが永遠にリソースを使えない。
    *   **Double Booking**: 1つのリソースが同時に2人に割り当てられる。

### (D) データ次元 (Data & Relation)
「システムが何を保持するか」という静的な構造。
*   **着眼点**: 1対1、1対多、必須項目、一意性制約
*   **よくある欠陥**:
    *   **Orphan**: 親データが消えたのに子データが残る。
    *   **Multiplicity Violation**: 「必ず1つ親を持つ」はずが、親不在のデータが生成可能である。

---

## 2. 検証プロセスの標準化 (Standard Workflow)

今回試行している手法は「形式検証（Formal Verification）」と「LLMによる翻訳」を組み合わせた **Neuro-Symbolic Approach** と呼ばれる最先端の手法です。これを標準フロー化すると以下のようになります。

### Step 1: 構造化抽出 (LLM)
自然言語のドキュメントを読み、上記の4次元にタグ付けする。
*   プロンプト例：「この仕様書から『状態遷移』、『数値条件』、『排他リソース』をリストアップしてください」

### Step 2: 形式化 (Modeling)
リストアップされた要素をAlloyコードに変換する。
*   この際、検証したい「性質（Property）」を `assert` として記述させる。
*   例：「デッドロックがないこと (NoDeadlock)」「ヌケモレがないこと (Completeness)」

### Step 3: 探索的検証 (Solving)
Alloyを実行し、反例（Counterexample）を探す。

### Step 4: 意味解釈 (Interpretation)
Alloyが出力した無味乾燥な反例データを、LLMが再度自然言語のストーリー（「バッテリーが18%の時にWiFiがつながっていると、システムはどの状態にも遷移できずフリーズします」）に翻訳して人間に提示する。

---

## 3. 「Alloy以外」のアプローチとの比較

| 手法 | 特徴 | ヌケモレ検出力 | 矛盾検出力 | コスト |
| :--- | :--- | :--- | :--- | :--- |
| **人間によるレビュー** | 文脈理解は最強だが、組み合わせ爆発に弱い。見落としが多い。 | 低 | 低 | 高 |
| **LLM単体レビュー** | 「一般的によくあるミス」の指摘は早いが、論理的な厳密性はない（幻覚を見る）。 | 中 | 低 | 低 |
| **テストケース自動生成** | 入力に対する出力を網羅する手法。実装フェーズ寄り。仕様そのものの矛盾は見つけにくい。 | 高 | 中 | 中 |
| **形式検証 (Alloy等) + LLM** | **論理構造を数学的に総当たりするため、定義された範囲内でのヌケモレ検出率は100%。** | **最高** | **最高** | 中 |

### 結論：どうするのがベストか？
「網羅的にチェックしたい」という目的であれば、**「仕様をモデル（数式）に変換してソルバで解く」** という現在のアプローチが理論上最強です。
人間やLLM単体では、「3つの条件が重なった時の稀な矛盾」を脳内でシミュレートしきれないからです。

今後の汎用的な展開としては、**「検証観点（Assert）のカタログ化」** が鍵になります。
毎回ゼロから考えるのではなく、「状態遷移ならこの3つのAssertを入れる」「リソース管理ならこの2つのAssertを入れる」というテンプレート・ライブラリを整備することをお勧めします。
