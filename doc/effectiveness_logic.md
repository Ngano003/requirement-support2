# 手戻り削減の論理的根拠 (Logic for Rework Reduction)

本ドキュメントは、「特定の欠陥（ヌケ・モレ・矛盾）を防ぐことが、なぜ・どれほどの手戻り削減につながるか」を論理的に説明するための資料です。

## 1. 基本理論：欠陥修正コストの指数関数的増大
ソフトウェア工学における定説（**1:10:100の法則**）に基づき、要件定義段階での欠陥除去は、後工程と比べて圧倒的に低コストです。

*   **要件定義で発見**: コスト **1** （ドキュメント修正のみ）
*   **実装・テストで発見**: コスト **10〜20** （コード修正 + テストやり直し）
*   **リリース後に発見**: コスト **100以上** （緊急パッチ、データ補正、信用毀損）

## 2. 戦略的な対象選定：なぜ「この3つ」なのか？

欠陥には様々な種類（用語の揺らぎ、タイミング矛盾、循環依存など）がありますが、本システムでは**パレートの法則（80:20の法則）**に基づき、最もROI（投資対効果）が高い以下の3つに意図的に絞り込んでいます。

| 欠陥タイプ | 発生頻度 | 影響度 | 検出アプローチ | 選定判断 |
| :--- | :--- | :--- | :--- | :--- |
| **1. Missing Else**<br>(条件漏れ) | **高 (No.1)** | 中 | **LLM推論 (易)** | **[採用]** 文脈理解が必要だが、最新LLMなら「もし〜でなければ」を容易に指摘可能。 |
| **2. Dead Ends**<br>(袋小路) | 中 | **大 (致命傷)** | **LLM推論 (中)** | **[採用]** 以前はグラフ化必須だったが、最新LLMは「状態遷移の追跡」が可能。影響度が甚大なため必須対象。 |
| **3. Conflicting Outputs**<br>(矛盾) | 低 | **特大 (事故)** | **LLM推論 (難)** | **[採用]** 複雑だが、発見できた場合のリスク回避効果（数週間の手戻り防止）が絶大なため挑戦する価値がある。 |
| *その他 (Orphan States)* | 低 | 小 | LLM推論 (中) | [除外] 「到達できない機能」は無駄だが、バグやシステム停止には直結しないためROIが低い。 |
| *その他 (Unstated Side Effects)* | 中 | 中 | LLM推論 (難) | [除外] 「何かが残っている」の判定は暗黙知に依存しやすく、誤検知（False Positive）で開発者を疲弊させる懸念がある。 |
| *その他 (Cycles/Deadlock)* | 低 | 大 | LLM推論 (難) | [除外] 意図的なループ（ポーリング等）との区別が難しく、LLMでは正確な判定が困難。 |
| *その他 (Ambiguous Terms)* | 中 | 小〜中 | LLM推論 (易) | [次点] 指摘は容易だが「表記ゆれ」程度ではシステムは止まらないため、優先度は一段下がる。 |
| *その他 (Timing Violation)* | 低 | 大 | 計算 (難) | [除外] 数値計算はLLMが最も苦手とする領域（ハルシネーション多発）のため、現段階では対象外。 |

つまり、**「頻度の高い日常的なムダ (Missing Else)」**と**「稀だが致命的な事故 (Dead Ends/Conflicts)」**の両端を抑える戦略です。従来は形式手法が必要だった後者も、LLMの進化により「自然言語のまま」検出可能になった点がブレイクスルーです。

## 3. ターゲットとする欠陥と手戻りのメカニズム

当AIが「優先度高」として検出する3つの欠陥タイプが、具体的にどのような「手戻り」を引き起こしているか、そしてそれを防ぐことでどう改善されるかを解説します。

### ① Missing Else（条件の網羅漏れ）
*   **現象**: 「Aの場合はBする」としか書かれておらず、「Aでない場合」が未定義。
*   **発生する手戻りプロセス（現状）**:
    1.  設計・実装者が「よしなに」解釈して実装する（例：何もしない、エラーにする）。
    2.  テスト段階で「この場合動かないんですけど？」とバグ報告される。
    3.  仕様確認に戻る。「あ、そこ決めてなかったね」→ **仕様追加 + コード修正 + 再テスト**。
*   **AI導入後の効果**:
    *   要件段階で「Aでない場合は？」と問われる。
    *   **手戻り削減効果**: **大**（頻度No.1）。エンジニアの「仕様確認待ち時間」と「解釈違いによるバグ修正」が消滅する。

### ② Dead Ends（状態の袋小路）
*   **現象**:特定のエラー画面や完了画面から、どこにも遷移できない（ホームに戻れない）。
*   **発生する手戻りプロセス（現状）**:
    1.  異常系のため、開発中のHappy Pathテストではスルーされる。
    2.  結合テストやユーザー受入テスト（UAT）で、テスターがたまたまエラーを起こして発覚。「画面が固まった」と重要バグ扱い。
    3.  **UIフロー全体の再設計**が必要になる場合もある。
*   **AI導入後の効果**:
    *   LLMが仮想的なユーザ操作をシミュレーションし、出口のないフローを検知する。
    *   **手戻り削減効果**: **中〜大**。発生頻度は中程度だが、見つかる時期が遅いため、修正コスト（手戻り距離）が長い。

### ③ Conflicting Outputs（矛盾する命令）
*   **現象**: 「ドアをロックする」と「ロックを解除する」という命令が、特定の複合条件下で同時に発生する。
*   **発生する手戻りプロセス（現状）**:
    1.  ハードウェア制御やDB更新で競合エラーが発生。
    2.  「たまに動かない」という再現性の低いバグとして調査に時間を浪費する。
    3.  根本原因が仕様の論理矛盾だと判明。**アーキテクチャレベルの修正**が必要になる。
*   **AI導入後の効果**:
    *   論理検証により、コーディング前に矛盾を排除。
    *   **手戻り削減効果**: **特大**（リスク回避）。数日〜数週間のデバッグ工数と、ハードウェア破損等の致命的リスクをゼロにする。

## 4. 期待できる定量効果（推計モデル）

仮に1プロジェクトで要件定義書のページ数が50ページ、欠陥が合計20個埋まっていると仮定した場合のシミュレーションです。

| 項目 | 従来（人力レビューのみ） | 本AI導入後（ハイブリッド検証） | 差分（削減効果） |
| :--- | :--- | :--- | :--- |
| **要件定義での発見** | 10個 (50%) | **18個 (90%)** | +8個 |
| **後工程への流出** | 10個 | **2個** | **-8個 (流出激減)** |
| **ドキュメント修正工数** | 10人時 | 18人時 | +8人時 (微増) |
| **手戻り修正工数** | 10個 × 20人時 = 200人時 | 2個 × 20人時 = 40人時 | **-160人時** |
| **トータル開発工数** | **210人時** | **58人時** | **約72% 削減** |

> ※ **要件定義での修正時間**は微増しますが、開発全体で見ると**「後工程での手戻り（高コストな修正）」が激減するため、トータル工数は大幅に削減されます**。

## 5. 結論
最も効果的なのは、**「頻度の高い Missing Else」と「影響の大きい Dead Ends / Conflicts」を機械的に潰すこと**です。
これにより、エンジニアは「仕様の穴埋め」ではなく「本質的な機能実装」に集中でき、プロジェクト全体の手戻りを最小化できます。
